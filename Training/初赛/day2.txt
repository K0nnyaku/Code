计数排序
基于统计而不基于比较
遇到数字对应位++
O(a+n)
插入排序 稳定
选择排序
先看第一张往后扫找到最小的与它交换
O(n^2)不稳定
冒泡排序
看相邻的数字是否有序一直到最后
O(n^2)稳定
插入排序
像打牌一样插入
O(n^2)稳定
归并排序 稳定
需要额外辅助空间
快速排序 不稳定
堆排序 不稳定
稳定：指保证val有序的同时key有序 key[i]=i
考点：
排序稳定性、（最好/坏）时空复杂度等

贪心：
需要证明有时候不正确
Huffman编码形如完全二叉树把最小的元素尽量放在最深层
考点：思维题

二分：
在单调性数组中提高查找效率的方法
注意算log时要上取整
eg 100个数最少猜几次
7次，因为log2(64)=6次不够。
显然log2(64)<log2(100)<log2(128)

递推：
要素：初始值 递推条件
从小问题到大问题
递归/分治：
从大问题到小问题
分治典型算法：归并 快排

数据结构：
栈先进后出
应用：Catalan数 后缀表达式 括号匹配
Catalan数 1 2 5 14 52
用于计算出栈序列数、括号匹配数等
考点：合法出栈序列

队列先进先出
考点：bfs、dijk

链表：ins/del
考点：链表的实现（在读程序里？）、特点
链表的特点：
插入删除不需要移动元素
不必事先估计存储空间
所需空间与线性表长度成正比
不能随机访问元素而是一个接一个
（2019pj）

树：n个点n-1条边所有节点连通且无环，可能有根以及层
考点：树的性质
二叉树！！！
高度 节点 叶子节点
下一层数量是上一层的两倍
每层的节点数量为2^(i-1)

考点：二叉树的存储（*2(+1)）、计算、遍历顺序知道两个求另外一个

遍历顺序指根节点在哪，如前序遍历则先遍历根
一句话描述知二求一：
前（后）序遍历第一个（最后一个）是根，在中序遍历中找到根并分为左右子树继续递归

表达式树：
考点：中缀转其他2018tg
从最里层括号（最先优先级）往上画二叉树，其中每个节点带有一个数字（字母）或者符号（括号不包括在内）
对最后唯一得到的二叉树进行前序或后序遍历，即可得到对应的前缀或后缀表达式。
显然除叶子节点是字母（数字）以外其他节点都是符号。注意建树时不要写括号

图：有节点，之间有连边的结构
可能有向（无向）、边（点）带权。
完全图的边数为n*(n-1)/2
简单图：无重边自环
度数：顶点连着边的条数
有向图分为入度和出度。
存储方式：邻接矩阵（稠密图）、邻接表（稀疏图）
考点：计算

最短路：
dijk floyd
最小生成树 prim（O(n^2)）kruskal（O(e log e)）贪心
欧拉回路：没有或两个奇数度的顶点存在回路